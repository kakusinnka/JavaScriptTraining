/* 变量提升 */
// ES6之前我们一般使用var来声明变量，提升简单来说就是把我们所写的类似于var a = 123;这样的代码，声明提升到它所在作用域的顶端去执行，到我们代码所在的位置来赋值。
// JavaScript 只有声明的变量会提升，初始化的不会。

/* --------------------------- 实例1 Start ---------------------------*/
// function test () {
//     console.log(a);  // undefined
//     var a = 123;
// };
// test();

// 上述代码a的结果是undefined，它的实际执行顺序如下：
// function test () {
//     var a;
//     console.log(a);
//     a = 123;
// }
// test();
/* --------------------------- 实例1 End ---------------------------*/

/* --------------------------- 实例2 Start ---------------------------*/
// 第一眼看到的时候是不是会认为undefined, 记住声明会提升到作用域顶端。
// a = 1;
// var a;
// console.log(a); // 1

// 实际执行的是
// var a;
// a = 1;
// console.log(a); // 1
/* --------------------------- 实例2 End ---------------------------*/

/* --------------------------- 实例3 Start ---------------------------*/
// 下面来看一道经典面试题
// console.log(v1); // undefined
// var v1 = 100;
// function foo() {
//     console.log(v1); // undefined
//     var v1 = 200;
//     console.log(v1); // 200
// }
// foo();
// console.log(v1); // 100

// 实际执行的是
// var v1;
// console.log(v1); // undefined
// v1 = 100;
// function foo() {
//     var v1;
//     console.log(v1); // undefined
//     v1 = 200;
//     console.log(v1); // 200
// }
// foo();
// console.log(v1); // 100
/* --------------------------- 实例3 End ---------------------------*/

/* 函数提升 */
// JavaScript中不仅仅是变量声明有提升的现象, 函数的声明也是一样；
// 具名函数的声明有两种方式：1. 函数声明式 2. 函数字面量式
// //函数声明式
// function bar () {}
// //函数字面量式
// var foo = function () {}

// 函数字面量式的声明合变量提升的结果是一样的, 函数只是一个具体的值；
// 但是函数声明式的提升现象和变量提升略有不同, 函数提升是整个代码块提升到它所在的作用域的最开始执行

/* --------------------------- 实例1 Start ---------------------------*/
// console.log(bar);
// function bar () {
//   console.log(1);
// }
//打印结果：
// ƒ bar () {
//   console.log(1);
// }

// 执行顺序相当于：
// function bar () {
//     console.log(1);
//   }
//   console.log(bar);
/* --------------------------- 实例1 End ---------------------------*/

/* --------------------------- 实例2 Start ---------------------------*/
// foo(); //1

// var foo;

// function foo () {
//     console.log(1);
// }

// foo = function () {
//     console.log(2);
// }

// 实际的执行顺序
// function foo () {
//     console.log(1);
// }

// var foo;

// foo(); //1

// foo = function () {
//     console.log(2);
// }
// 这就是函数优先规则
/* --------------------------- 实例2 End ---------------------------*/

/* --------------------------- 实例3 Start ---------------------------*/
// foo(); //低版本：2  //高版本： Uncaught TypeError: foo is not a function

// var a = true;

// if (a) {
//     function foo () { console.log(1); }
// } else {
//     function foo () { console.log(2); }
// }
// 上面这段代码，在低版本的浏览器中，函数提升不会被条件判断所控制，输出2。
// 但是在高版本的浏览器中会报错，所以应该尽可能避免在块内部声明函数
/* --------------------------- 实例3 End ---------------------------*/

/* --------------------------- 实例4 Start ---------------------------*/
// 使用匿名函数的方式不存在函数提升，因为函数名称使用变量表示的，只存在变量提升。例：
// var getName = function () {
//   console.log(2);
// };

// function getName() {
//   console.log(1);
// }

// getName();
//结果为2

// 函数、变量声明提升后
// function getName() {
//   //函数声明提升到顶部
//   console.log(1);
// }

// var getName; //变量声明提升
// getName = function () {
//   //变量赋值依然保留在原来的位置
//   console.log(2);
// };

// getName(); // 最终输出：2
/* --------------------------- 实例4 End ---------------------------*/
